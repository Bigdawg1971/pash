namespace Microsoft.PowerShell.Commands
{
    using System;
    using System.Globalization;
    using System.Management.Automation;
    using System.Management.Automation.Internal;

    [Cmdlet("Get", "PSSessionConfiguration", HelpUri="http://go.microsoft.com/fwlink/?LinkID=144304"), OutputType(new string[] { "Microsoft.PowerShell.Commands.PSSessionConfigurationCommands#PSSessionConfiguration" })]
    public sealed class GetPSSessionConfigurationCommand : PSCmdlet
    {
        private static readonly ScriptBlock getPluginSb = ScriptBlock.Create(string.Format(CultureInfo.InvariantCulture, "\r\nfunction ExtractPluginProperties([string]$pluginDir, $objectToWriteTo) \r\n{{\r\n    function Unescape-Xml($s) {{\r\n        if ($s) {{\r\n            $s = $s.Replace(\"&amp;\", \"&\");\r\n            $s = $s.Replace(\"&lt;\", \"<\");\r\n            $s = $s.Replace(\"&gt;\", \">\");\r\n            $s = $s.Replace(\"&quot;\", '\"');\r\n            $s = $s.Replace(\"&apos;\", \"'\");\r\n        }}        \r\n        return $s;\r\n    }}\r\n\r\n    $hashprovider = new-object system.collections.CaseInsensitiveHashCodeProvider\r\n    $comparer=new-object system.collections.CaseInsensitiveComparer\r\n    $h = new-object system.collections.hashtable([System.Collections.IHashCodeProvider]$hashprovider, [System.Collections.IComparer]$comparer)\r\n    \r\n    function Get-Details([string]$path, [hashtable]$h) {{\r\n        foreach ($o in (get-childitem -LiteralPath $path)) {{\r\n            if ($o.PSIsContainer) {{\r\n                Get-Details $o.PSPath $h\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n        \r\n    Get-Details $pluginDir $h\r\n        \r\n    if ($h[\"AssemblyName\"] -eq \"Microsoft.PowerShell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\") {{\r\n        \r\n        $serviceCore = [Reflection.Assembly]::Load(\"Microsoft.Powershell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\")\r\n        \r\n        if ($serviceCore -ne $null) {{\r\n\r\n            $ci = new-Object system.management.automation.cmdletinfo \"New-PSWorkflowExecutionOptions\", ([Microsoft.PowerShell.Commands.NewPSWorkflowExecutionOptionCommand])\r\n            $wf = [powershell]::Create(\"currentrunspace\").AddCommand($ci).Invoke()\r\n    \r\n            if($wf -ne $null -and $wf.Count -ne 0) {{              \r\n                $wf = $wf[0]\r\n\r\n                foreach ($o in $wf.GetType().GetProperties()) {{\r\n                    $h[$o.Name] = $o.GetValue($wf, $null)\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if (test-path -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData) {{\r\n        $xscd = [xml](Unescape-xml (get-item -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData).Value)\r\n\r\n        foreach ($o in $xscd.SessionConfigurationData.Param) {{\r\n            if ($o.Name -eq \"PrivateData\") {{\r\n                foreach($wf in $o.PrivateData.Param) {{\r\n                    $h[$wf.Name] = $wf.Value\r\n                }}\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    ## Extract DISC related information\r\n    if(test-path -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath) {{\r\n        $DISCFilePath = (get-item -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath).Value\r\n\r\n        if(test-path -LiteralPath $DISCFilePath) {{\r\n            $DISCFileContent = get-content $DISCFilePath | out-string\r\n            $DISCHash = invoke-expression $DISCFileContent\r\n\r\n            foreach ($o in $DISCHash.Keys) {{   \r\n                if ($o -ne \"PowerShellVersion\") {{\r\n                    $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $DISCHash[$o] -force -passthru\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if ($h[\"SessionConfigurationData\"]) {{\r\n        $h[\"SessionConfigurationData\"] = Unescape-Xml $h[\"SessionConfigurationData\"]\r\n    }}\r\n\r\n    foreach ($o in $h.Keys) {{\r\n        if ($o -eq 'sddl') {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name 'SecurityDescriptorSddl' -value $h[$o] -force -passthru\r\n        }} else {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $h[$o] -force -passthru\r\n        }}\r\n    }}\r\n}}\r\n\r\n$shellNotErrMsgFormat = $args[1]\r\n$args[0] | foreach {{\r\n  $shellsFound = 0;\r\n  $filter = $_\r\n  dir 'WSMan:\\localhost\\Plugin\\' | ? {{ $_.name -like \"$filter\" }} | foreach {{\r\n     $customPluginObject = new-object object     \r\n     $customPluginObject.pstypenames.Insert(0, '{0}')\r\n     ExtractPluginProperties \"$($_.PSPath)\" $customPluginObject\r\n     # this is powershell based custom shell only if its plugin dll is pwrshplugin.dll\r\n     if (($customPluginObject.FileName) -and ($customPluginObject.FileName -match '{1}'))\r\n     {{\r\n        $shellsFound++\r\n        $customPluginObject\r\n     }}\r\n    }} # end of foreach\r\n   \r\n    if (!$shellsFound -and !([System.Management.Automation.WildcardPattern]::ContainsWildcardCharacters($_)))\r\n    {{\r\n      $errMsg = $shellNotErrMsgFormat -f $_\r\n      Write-Error $errMsg \r\n    }}     \r\n  }}\r\n", new object[] { "Microsoft.PowerShell.Commands.PSSessionConfigurationCommands#PSSessionConfiguration", "pwrshplugin.dll" }));
        private const string getPluginSbFormat = "\r\nfunction ExtractPluginProperties([string]$pluginDir, $objectToWriteTo) \r\n{{\r\n    function Unescape-Xml($s) {{\r\n        if ($s) {{\r\n            $s = $s.Replace(\"&amp;\", \"&\");\r\n            $s = $s.Replace(\"&lt;\", \"<\");\r\n            $s = $s.Replace(\"&gt;\", \">\");\r\n            $s = $s.Replace(\"&quot;\", '\"');\r\n            $s = $s.Replace(\"&apos;\", \"'\");\r\n        }}        \r\n        return $s;\r\n    }}\r\n\r\n    $hashprovider = new-object system.collections.CaseInsensitiveHashCodeProvider\r\n    $comparer=new-object system.collections.CaseInsensitiveComparer\r\n    $h = new-object system.collections.hashtable([System.Collections.IHashCodeProvider]$hashprovider, [System.Collections.IComparer]$comparer)\r\n    \r\n    function Get-Details([string]$path, [hashtable]$h) {{\r\n        foreach ($o in (get-childitem -LiteralPath $path)) {{\r\n            if ($o.PSIsContainer) {{\r\n                Get-Details $o.PSPath $h\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n        \r\n    Get-Details $pluginDir $h\r\n        \r\n    if ($h[\"AssemblyName\"] -eq \"Microsoft.PowerShell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\") {{\r\n        \r\n        $serviceCore = [Reflection.Assembly]::Load(\"Microsoft.Powershell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\")\r\n        \r\n        if ($serviceCore -ne $null) {{\r\n\r\n            $ci = new-Object system.management.automation.cmdletinfo \"New-PSWorkflowExecutionOptions\", ([Microsoft.PowerShell.Commands.NewPSWorkflowExecutionOptionCommand])\r\n            $wf = [powershell]::Create(\"currentrunspace\").AddCommand($ci).Invoke()\r\n    \r\n            if($wf -ne $null -and $wf.Count -ne 0) {{              \r\n                $wf = $wf[0]\r\n\r\n                foreach ($o in $wf.GetType().GetProperties()) {{\r\n                    $h[$o.Name] = $o.GetValue($wf, $null)\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if (test-path -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData) {{\r\n        $xscd = [xml](Unescape-xml (get-item -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData).Value)\r\n\r\n        foreach ($o in $xscd.SessionConfigurationData.Param) {{\r\n            if ($o.Name -eq \"PrivateData\") {{\r\n                foreach($wf in $o.PrivateData.Param) {{\r\n                    $h[$wf.Name] = $wf.Value\r\n                }}\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    ## Extract DISC related information\r\n    if(test-path -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath) {{\r\n        $DISCFilePath = (get-item -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath).Value\r\n\r\n        if(test-path -LiteralPath $DISCFilePath) {{\r\n            $DISCFileContent = get-content $DISCFilePath | out-string\r\n            $DISCHash = invoke-expression $DISCFileContent\r\n\r\n            foreach ($o in $DISCHash.Keys) {{   \r\n                if ($o -ne \"PowerShellVersion\") {{\r\n                    $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $DISCHash[$o] -force -passthru\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if ($h[\"SessionConfigurationData\"]) {{\r\n        $h[\"SessionConfigurationData\"] = Unescape-Xml $h[\"SessionConfigurationData\"]\r\n    }}\r\n\r\n    foreach ($o in $h.Keys) {{\r\n        if ($o -eq 'sddl') {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name 'SecurityDescriptorSddl' -value $h[$o] -force -passthru\r\n        }} else {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $h[$o] -force -passthru\r\n        }}\r\n    }}\r\n}}\r\n\r\n$shellNotErrMsgFormat = $args[1]\r\n$args[0] | foreach {{\r\n  $shellsFound = 0;\r\n  $filter = $_\r\n  dir 'WSMan:\\localhost\\Plugin\\' | ? {{ $_.name -like \"$filter\" }} | foreach {{\r\n     $customPluginObject = new-object object     \r\n     $customPluginObject.pstypenames.Insert(0, '{0}')\r\n     ExtractPluginProperties \"$($_.PSPath)\" $customPluginObject\r\n     # this is powershell based custom shell only if its plugin dll is pwrshplugin.dll\r\n     if (($customPluginObject.FileName) -and ($customPluginObject.FileName -match '{1}'))\r\n     {{\r\n        $shellsFound++\r\n        $customPluginObject\r\n     }}\r\n    }} # end of foreach\r\n   \r\n    if (!$shellsFound -and !([System.Management.Automation.WildcardPattern]::ContainsWildcardCharacters($_)))\r\n    {{\r\n      $errMsg = $shellNotErrMsgFormat -f $_\r\n      Write-Error $errMsg \r\n    }}     \r\n  }}\r\n";
        private const string MODULEPATH = "ModulesToImport";
        private string[] shellName;

        static GetPSSessionConfigurationCommand()
        {
            getPluginSb.LanguageMode = 0;
        }

        protected override void BeginProcessing()
        {
            RemotingCommandUtil.CheckRemotingCmdletPrerequisites();
            PSSessionConfigurationCommandUtilities.ThrowIfNotAdministrator();
        }

        protected override void ProcessRecord()
        {
            base.WriteVerbose(StringUtil.Format(RemotingErrorIdStrings.GcsScriptMessageV, "\r\nfunction ExtractPluginProperties([string]$pluginDir, $objectToWriteTo) \r\n{{\r\n    function Unescape-Xml($s) {{\r\n        if ($s) {{\r\n            $s = $s.Replace(\"&amp;\", \"&\");\r\n            $s = $s.Replace(\"&lt;\", \"<\");\r\n            $s = $s.Replace(\"&gt;\", \">\");\r\n            $s = $s.Replace(\"&quot;\", '\"');\r\n            $s = $s.Replace(\"&apos;\", \"'\");\r\n        }}        \r\n        return $s;\r\n    }}\r\n\r\n    $hashprovider = new-object system.collections.CaseInsensitiveHashCodeProvider\r\n    $comparer=new-object system.collections.CaseInsensitiveComparer\r\n    $h = new-object system.collections.hashtable([System.Collections.IHashCodeProvider]$hashprovider, [System.Collections.IComparer]$comparer)\r\n    \r\n    function Get-Details([string]$path, [hashtable]$h) {{\r\n        foreach ($o in (get-childitem -LiteralPath $path)) {{\r\n            if ($o.PSIsContainer) {{\r\n                Get-Details $o.PSPath $h\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n        \r\n    Get-Details $pluginDir $h\r\n        \r\n    if ($h[\"AssemblyName\"] -eq \"Microsoft.PowerShell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\") {{\r\n        \r\n        $serviceCore = [Reflection.Assembly]::Load(\"Microsoft.Powershell.Workflow.ServiceCore, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, processorArchitecture=MSIL\")\r\n        \r\n        if ($serviceCore -ne $null) {{\r\n\r\n            $ci = new-Object system.management.automation.cmdletinfo \"New-PSWorkflowExecutionOptions\", ([Microsoft.PowerShell.Commands.NewPSWorkflowExecutionOptionCommand])\r\n            $wf = [powershell]::Create(\"currentrunspace\").AddCommand($ci).Invoke()\r\n    \r\n            if($wf -ne $null -and $wf.Count -ne 0) {{              \r\n                $wf = $wf[0]\r\n\r\n                foreach ($o in $wf.GetType().GetProperties()) {{\r\n                    $h[$o.Name] = $o.GetValue($wf, $null)\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if (test-path -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData) {{\r\n        $xscd = [xml](Unescape-xml (get-item -LiteralPath $pluginDir\\InitializationParameters\\SessionConfigurationData).Value)\r\n\r\n        foreach ($o in $xscd.SessionConfigurationData.Param) {{\r\n            if ($o.Name -eq \"PrivateData\") {{\r\n                foreach($wf in $o.PrivateData.Param) {{\r\n                    $h[$wf.Name] = $wf.Value\r\n                }}\r\n            }} else {{\r\n                $h[$o.Name] = $o.Value\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    ## Extract DISC related information\r\n    if(test-path -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath) {{\r\n        $DISCFilePath = (get-item -LiteralPath $pluginDir\\InitializationParameters\\ConfigFilePath).Value\r\n\r\n        if(test-path -LiteralPath $DISCFilePath) {{\r\n            $DISCFileContent = get-content $DISCFilePath | out-string\r\n            $DISCHash = invoke-expression $DISCFileContent\r\n\r\n            foreach ($o in $DISCHash.Keys) {{   \r\n                if ($o -ne \"PowerShellVersion\") {{\r\n                    $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $DISCHash[$o] -force -passthru\r\n                }}\r\n            }}\r\n        }}\r\n    }}\r\n\r\n    if ($h[\"SessionConfigurationData\"]) {{\r\n        $h[\"SessionConfigurationData\"] = Unescape-Xml $h[\"SessionConfigurationData\"]\r\n    }}\r\n\r\n    foreach ($o in $h.Keys) {{\r\n        if ($o -eq 'sddl') {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name 'SecurityDescriptorSddl' -value $h[$o] -force -passthru\r\n        }} else {{\r\n            $objectToWriteTo = $objectToWriteTo | add-member -membertype noteproperty -name $o -value $h[$o] -force -passthru\r\n        }}\r\n    }}\r\n}}\r\n\r\n$shellNotErrMsgFormat = $args[1]\r\n$args[0] | foreach {{\r\n  $shellsFound = 0;\r\n  $filter = $_\r\n  dir 'WSMan:\\localhost\\Plugin\\' | ? {{ $_.name -like \"$filter\" }} | foreach {{\r\n     $customPluginObject = new-object object     \r\n     $customPluginObject.pstypenames.Insert(0, '{0}')\r\n     ExtractPluginProperties \"$($_.PSPath)\" $customPluginObject\r\n     # this is powershell based custom shell only if its plugin dll is pwrshplugin.dll\r\n     if (($customPluginObject.FileName) -and ($customPluginObject.FileName -match '{1}'))\r\n     {{\r\n        $shellsFound++\r\n        $customPluginObject\r\n     }}\r\n    }} # end of foreach\r\n   \r\n    if (!$shellsFound -and !([System.Management.Automation.WildcardPattern]::ContainsWildcardCharacters($_)))\r\n    {{\r\n      $errMsg = $shellNotErrMsgFormat -f $_\r\n      Write-Error $errMsg \r\n    }}     \r\n  }}\r\n"));
            string customShellNotFound = RemotingErrorIdStrings.CustomShellNotFound;
            object shellName = "*";
            if (this.shellName != null)
            {
                shellName = this.shellName;
            }
            ActionPreference errorActionPreferenceVariable = base.Context.ErrorActionPreferenceVariable;
            try
            {
                if (base.Context.CurrentCommandProcessor.CommandRuntime.IsErrorActionSet)
                {
                    base.Context.ErrorActionPreferenceVariable = base.Context.CurrentCommandProcessor.CommandRuntime.ErrorAction;
                }
                getPluginSb.InvokeUsingCmdlet(this, true, ScriptBlock.ErrorHandlingBehavior.WriteToCurrentErrorPipe, AutomationNull.Value, new object[0], AutomationNull.Value, new object[] { shellName, customShellNotFound });
            }
            finally
            {
                base.Context.ErrorActionPreferenceVariable = errorActionPreferenceVariable;
            }
        }

        [Parameter(Position=0, Mandatory=false)]
        public string[] Name
        {
            get
            {
                return this.shellName;
            }
            set
            {
                this.shellName = value;
            }
        }
    }
}

